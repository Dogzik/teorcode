\documentclass[fontsize=14pt]{article}

\usepackage{listings}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{scrextend}
\usepackage{hyperref}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{listings}
\usepackage{csquotes}

\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
    filecolor=magenta,      
    urlcolor=blue,
}

\linespread{1.3}
\parindent=0.6cm
\lstset{tabsize = 2}

\title{Домашнее задание №1}
\author{Лев Довжик, M3439 \\ Вариант №62}
\date{}


\begin{document}
	\pagenumbering{gobble}
	\maketitle
	
\section*{Начальные условия}

	Проверочная матрица $H = 
 	\begin{pmatrix}
		1\ 1\ 1\ 0\ 1\ 0\ 0\ 1\ 0\ 1\\
		1\ 0\ 0\ 0\ 0\ 0\ 1\ 1\ 1\ 1\\
		1\ 1\ 0\ 1\ 0\ 1\ 1\ 1\ 0\ 0\\
		0\ 1\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ 0
	\end{pmatrix}
	$
	
\section*{№1 Скорость кода}


	Матрица $H$ имеет $n = 10$ столбцов и $r = n - k = 4$ строк, а значит $n = 10, k = 6, r = 4$, и скорость кода $R = \dfrac{k}{n} = \dfrac{3}{5} = 0.6\ \dfrac{bit}{symbol}$ 

\section*{№2 Минимальное расстояние кода}

Заметим, что любые два столбца проверочной матрицы независимы (т.к. все столбцы различны). При этом первый, четвёртый и десятый столбец в сумме дают нулевой вектор: 
$\begin{pmatrix}1\\1\\1\\0\end{pmatrix} + \begin{pmatrix}0\\0\\1\\0\end{pmatrix} +  
\begin{pmatrix}1\\1\\0\\0\end{pmatrix} = \begin{pmatrix}0\\0\\0\\0\end{pmatrix}$.\\

Откуда по теореме $2.4$ получаем, что минимальное расстояние $d = 3$.

\section*{№3 Расстрояние кода}

\subsection*{3.1 Граница Хэмминга}

\paragraph*{}
Для нашего $(10, 6, 3)$ кода $M = 2^k,\ q = 2$ и граница Хэмминга принимает вид: $2^k \leq \dfrac{2^n}{\sum\limits_{i = 0}^t C_i^n \left(2 - 1
\right) ^ i} 
\Rightarrow 
2^k \leq \dfrac{2^n}{\sum\limits_{i = 0}^t C_i^n}
\Rightarrow
\sum\limits_{i = 0}^t C_i^n \leq 2^{n - k}
\Rightarrow
\sum\limits_{i = 0}^t C_i^{10} \leq 16
$

\paragraph*{}
Найдём такое максимальное $d$, для которого выполняется данное соотношение при $t = \lfloor \dfrac{d - 1}{2} \rfloor$:

\begin{lstlisting}[frame=single, language=Python]
from scipy import special


def check_hamming(n, k, d):
    t = (d - 1) // 2
    total = 0
    for i in range(t + 1):
        total += special.comb(n, i)
    return total <= 2 ** (n - k)


d = 1
n = 10
k = 6
while check_hamming(n, k, d):
    d += 1
d -= 1
print(d)
# 4	
\end{lstlisting}

Таким образом получаем, что верхняя граница для $d$ равна $4$. То есть не существует никакого двоичного линейного $(10, 6)$-кода с минимальным расстоянием больше $4$.

\subsection*{3.2 Граница Варшамова-Гилберта}

При $q = 2$ граница Варшамова-Гилберта принимает вид: $2^{n - 1} > \sum\limits_{i = 0}^{d - 2} C_i^{n - 1}(2 - 1)^i$. Что в нашем случае превращается в $\sum\limits_{i = 0}^{d - 2} C_i^9 < 16$.
 
Найдём максимальное $d$, что которого выполняется данное соотношение, что будет означать существование $(10, 6)$-кода с таким минимальным расстоянием:

\begin{lstlisting}[frame=single, language=Python]
from scipy import special


def check_varshamov(n, k, d):
    total = 0
    for i in range(d - 1):
        total += special.comb(n - 1, i)
    return total < 2 ** (n - k)


d = 1
n = 10
k = 6
while check_varshamov(n, k, d):
    d += 1
d -= 1
print(d)
# 3
\end{lstlisting}

Таким образом существует двоичный линейный $(10, 6)$-код с минимальным расстоянием $d = 3$.

\subsection*{3.3 Проверка оптимальности}

\paragraph*{}
Из вышеоисанного имеем, что для минимального расстояние оптимальное кода стоит искать в диапазоне от $3$ до $4$. Исследуемый код попадает в данный диапазон. К тому же по данным сайта \href{http://www.codetables.de}{codetables.de}, а также таблицы $3.2$, лучший двоичный линейный $(10, 6)$-код имеет минимальное расстояние $d = 3$, следовательно наш код является оптимальным. 
\section*{№4 Порождающая матрица}
	Приведём проверочную матрицу к систематическому виду.\\
	Исходная матрица: 
	$
	 \begin{pmatrix}
		1\ 1\ 1\ 0\ 1\ 0\ 0\ 1\ 0\ 1\\
		1\ 0\ 0\ 0\ 0\ 0\ 1\ 1\ 1\ 1\\
		1\ 1\ 0\ 1\ 0\ 1\ 1\ 1\ 0\ 0\\
		0\ 1\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ 0
	\end{pmatrix}
	$\\
	
	Меняем $2$ и $4$ строки местами:
	 $
	 \begin{pmatrix}
		1\ 1\ 1\ 0\ 1\ 0\ 0\ 1\ 0\ 1\\
		0\ 1\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ 0\\
		1\ 1\ 0\ 1\ 0\ 1\ 1\ 1\ 0\ 0\\
		1\ 0\ 0\ 0\ 0\ 0\ 1\ 1\ 1\ 1		
	\end{pmatrix}
	$\\
	
	Прибавим $2$ строку к $1$ и $3$: 
	$
	 \begin{pmatrix}
		1\ 0\ 0\ 0\ 1\ 1\ 0\ 0\ 0\ 1\\
		0\ 1\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ 0\\
		1\ 0\ 1\ 1\ 0\ 0\ 1\ 0\ 0\ 0\\
		1\ 0\ 0\ 0\ 0\ 0\ 1\ 1\ 1\ 1		
	\end{pmatrix}
	$\\

	Прибавим к $4$ строке первые три:
	$
	 \begin{pmatrix}
		1\ 0\ 0\ 0\ 1\ 1\ 0\ 0\ 0\ 1\\
		0\ 1\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ 0\\
		1\ 0\ 1\ 1\ 0\ 0\ 1\ 0\ 0\ 0\\
		1\ 1\ 0\ 1\ 1\ 0\ 0\ 0\ 1\ 0		
	\end{pmatrix}
	$\\
	
	Переупорядочим стоки, приведя к систематическому виду:
	$
	 \begin{pmatrix}
	 	1\ 0\ 1\ 1\ 0\ 0\ 1\ 0\ 0\ 0\\
	 	0\ 1\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ 0\\
	 	1\ 1\ 0\ 1\ 1\ 0\ 0\ 0\ 1\ 0\\
		1\ 0\ 0\ 0\ 1\ 1\ 0\ 0\ 0\ 1		
	\end{pmatrix}
	$
	Значит $P^T = 
	 \begin{pmatrix}
	 	1\ 0\ 1\ 1\ 0\ 0\\
	 	0\ 1\ 1\ 0\ 0\ 1\\
	 	1\ 1\ 0\ 1\ 1\ 0\\
		1\ 0\ 0\ 0\ 1\ 1		
	\end{pmatrix}
	$,
	$P =
	 \begin{pmatrix}
		1\ 0\ 1\ 1\\
		0\ 1\ 1\ 0\\
		1\ 1\ 0\ 0\\
		1\ 0\ 1\ 0\\
		0\ 0\ 1\ 1\\
		0\ 1\ 0\ 1	
	\end{pmatrix}$, a
	$	G = 
	\begin{pmatrix}
		1\ 0\ 0\ 0\ 0\ 0\ 1\ 0\ 1\ 1\\
		0\ 1\ 0\ 0\ 0\ 0\ 0\ 1\ 1\ 0\\
		0\ 0\ 1\ 0\ 0\ 0\ 1\ 1\ 0\ 0\\
		0\ 0\ 0\ 1\ 0\ 0\ 1\ 0\ 1\ 0\\
		0\ 0\ 0\ 0\ 1\ 0\ 0\ 0\ 1\ 1\\
		0\ 0\ 0\ 0\ 0\ 1\ 0\ 1\ 0\ 1	
	\end{pmatrix}
	$\\
	
	В конце проверяем, что $G \cdot P^T = O_{k \times n}$
	
\begin{lstlisting}[frame=single, language=Python]
import numpy as np
 
G = np.array([[1, 0, 0, 0, 0, 0, 1, 0, 1, 1],
              [0, 1, 0, 0, 0, 0, 0, 1, 1, 0],
              [0, 0, 1, 0, 0, 0, 1, 1, 0, 0],
              [0, 0, 0, 1, 0, 0, 1, 0, 1, 0],
              [0, 0, 0, 0, 1, 0, 0, 0, 1, 1],
              [0, 0, 0, 0, 0, 1, 0, 1, 0, 1]])
 
H = np.array([[1, 1, 1, 0, 1, 0, 0, 1, 0, 1],
              [1, 0, 0, 0, 0, 0, 1, 1, 1, 1],
              [1, 1, 0, 1, 0, 1, 1, 1, 0, 0],
              [0, 1, 1, 0, 0, 1, 0, 1, 0, 0]])
 
H_t = H.transpose()
res = np.matmul(G, H_t) % 2
print(res)
# [[0 0 0 0]
#  [0 0 0 0]
#  [0 0 0 0]
#  [0 0 0 0]
#  [0 0 0 0]
#  [0 0 0 0]]	
\end{lstlisting}

\section*{№5 Кодировка сообщения}

Пусть $m = (1\ 1\ 0\ 1\ 0\ 0)$, тогда $c = m \cdot G = (1\ 1\ 0\ 1\ 0\ 0) \cdot
\begin{pmatrix}
		1\ 0\ 0\ 0\ 0\ 0\ 1\ 0\ 1\ 1\\
		0\ 1\ 0\ 0\ 0\ 0\ 0\ 1\ 1\ 0\\
		0\ 0\ 1\ 0\ 0\ 0\ 1\ 1\ 0\ 0\\
		0\ 0\ 0\ 1\ 0\ 0\ 1\ 0\ 1\ 0\\
		0\ 0\ 0\ 0\ 1\ 0\ 0\ 0\ 1\ 1\\
		0\ 0\ 0\ 0\ 0\ 1\ 0\ 1\ 0\ 1	
	\end{pmatrix}$.
То есть $c = (1\ 1\ 0\ 1\ 0\ 0\ 0\ 1\ 1\ 1)$
	
\section*{№6 Информационная совокупность}

Заметим, что при \enquote{систематизации} матрицы $H$ мы нигде не перестовляли столбцы, значит нам не нужна перенумеровка стобцов в $G$. При этом первый $k = 6$ столбцов матрицы $G$ образают единичную подматрицу, а следовательно линейно назависимы. Из всего вышесказанного получаем, что информационная совокупность равна $(1, 2, 3, 4, 5, 6)$  	

\section*{№11 Таблица синдромного декодирования}

Всего у нас существует $2^r = 2^4 = 16$ синдромов. Нулевому синдрому, очевидно, соотвествует нулевой вектор ошибок. А так же, в силу того что строки $H^T$ различны, каждому вектору ошибок веса $1$ будет соотвествовать свой уникальный синдром. Итого мы построили таблицу для 11 синдромов из 16:\\
$H^T = \begin{pmatrix}
1\ 1\ 1\ 0\\
1\ 0\ 1\ 1\\
1\ 0\ 0\ 1\\
0\ 0\ 1\ 0\\
1\ 0\ 0\ 0\\
0\ 0\ 1\ 1\\
0\ 1\ 1\ 0\\
1\ 1\ 1\ 1\\
0\ 1\ 0\ 0\\
1\ 1\ 0\ 0
\end{pmatrix}$
\hfill
\begin{tabular}{ |c|c| } 
\hline
s & e\\
\hline\hline 
0 0 0 0 & 0 0 0 0 0 0 0 0 0 0\\
\hline 
0 0 0 1 & ?\\
\hline
0 0 1 0 & 0 0 0 1 0 0 0 0 0 0\\ 
\hline
0 0 1 1 & 0 0 0 0 0 1 0 0 0 0\\ 
\hline
0 1 0 0 & 0 0 0 0 0 0 0 0 1 0\\ 
\hline
0 1 0 1 & ?\\ 
\hline
0 1 1 0 & 0 0 0 0 0 0 1 0 0 0\\ 
\hline
0 1 1 1 & ?\\ 
\hline
1 0 0 0 & 0 0 0 0 1 0 0 0 0 0\\ 
\hline
1 0 0 1 & 0 0 1 0 0 0 0 0 0 0\\
\hline
1 0 1 0 & ?\\ 
\hline
1 0 1 1 & 0 1 0 0 0 0 0 0 0 0\\ 
\hline
1 1 0 0 & 0 0 0 0 0 0 0 0 0 1\\ 
\hline
1 1 0 1 & ?\\ 
\hline
1 1 1 0 & 1 0 0 0 0 0 0 0 0 0\\ 
\hline
1 1 1 1 & 0 0 0 0 0 0 0 1 0 0\\
\hline
\end{tabular}

\paragraph*{}
Оставшиеся синдромы будут иметь соотвествующие им вектора ошибок веса хотя бы $2$. Заметим, что синдром $(0\ 0\ 0\ 1)$ получается складыванием $1$ и $8$ строк, $(0\ 1\ 0\ 1)$ --- $6$ и $7$, $(0\ 1\ 1\ 1)$ --- $5$ и $8$, $(1\ 0\ 1\ 0)$ --- $1$ и $9$, $(1\ 0\ 1\ 1)$ --- $8$ и $9$. Вес меньше двух они иметь не могут, а значит мы нашли минимальные вектора для данных синдромов. Итоговая таблица синдромного декодирования:

\begin{center}
\begin{tabular}{ |c|c| } 
\hline
s & e\\
\hline\hline 
0 0 0 0 & 0 0 0 0 0 0 0 0 0 0\\
\hline
0 0 0 1 & 1 0 0 0 0 0 0 1 0 0\\
\hline
0 0 1 0 & 0 0 0 1 0 0 0 0 0 0\\ 
\hline
0 0 1 1 & 0 0 0 0 0 1 0 0 0 0\\ 
\hline
0 1 0 0 & 0 0 0 0 0 0 0 0 1 0\\ 
\hline
0 1 0 1 & 0 0 0 0 0 1 1 0 0 0\\ 
\hline
0 1 1 0 & 0 0 0 0 0 0 1 0 0 0\\ 
\hline
0 1 1 1 & 0 0 0 0 1 0 0 1 0 0\\ 
\hline
1 0 0 0 & 0 0 0 0 1 0 0 0 0 0\\ 
\hline
1 0 0 1 & 0 0 1 0 0 0 0 0 0 0\\
\hline
1 0 1 0 & 1 0 0 0 0 0 0 0 1 0\\ 
\hline
1 0 1 1 & 0 1 0 0 0 0 0 0 0 0\\ 
\hline
1 1 0 0 & 0 0 0 0 0 0 0 0 0 1\\ 
\hline
1 1 0 1 & 0 0 0 0 0 0 0 1 1 0\\ 
\hline
1 1 1 0 & 1 0 0 0 0 0 0 0 0 0\\ 
\hline
1 1 1 1 & 0 0 0 0 0 0 0 1 0 0\\
\hline
\end{tabular}
\end{center}

\end{document}
